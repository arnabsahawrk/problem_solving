*set   // ordered, unique elements,  O(logN) for insertion    (internal using balanced binary tree)

*unordered_set  // unordered, unique elements,  O(1) for insertion (internal using hashing)

*multiset  //ordered, not unique elements, O(logN) for insertion

*unordered_mutiset  // unordered, not unique, O(1) for insertion

*map, unordered_map

*random_shuffle(v.begin(), v.end())

Bitset
-------
A bitset is an array whose each value is either 0 or 1. For example, the following code creates a bitset that contains 10 elements:
bitset<10> s;
s[1] = 1;
s[3] = 1;
s[4] = 1;
s[7] = 1;
cout<<s[4]<<"\n";  \\ 1
cout<<s[5]<<"\n";  \\ 0

bitset<10> s(string("0010011010")); // from right to left
cout<<s[4]<<"\n"; \\ 1
cout<<s[5]<<"\n";  \\ 0

The bitset of using bitsets is that they require less memory than ordinary arrays, because each element in a bitset only uses one bit of memory. For example, if n bits are sorted in an int array, 32n bits of memory will be used, but a corresponding bitset only requires n bits of memory. In addition, the values of a bitset can be efficiently manipulated using bit operators, which makes it possible to optimize algorithms using bit sets. unlike array its index represent from right to left.

.test(pos)  // returns the boolean value at given index.
.count()  // count the number of setbit.
.any() //checks if any bit is set.
.none()  //check if all bits are unset.
.all()  //check if all bit is set.
.size()  // returns the size of the bitset.

bitset<10> s(string("0010011010"));
cout<<s.count()<<"\n" \\4

bitset<5> bs(18); \\ 10010

//set 1st bit
bs.set(0);
cout<<bs<<endl;  \\10011

//reset 2nd bit
bs.reset(1);
cout<<bs<<endl;  \\10001

//Flip 5th bit
bs.flip(4); //00001

cout<<(bs1 & bs2)<<endl;
cout<<(bs1 ^ bs2)<<endl;
cout<<(bs1 | bs2)<<endl;